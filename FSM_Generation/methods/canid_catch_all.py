# This program is used to generate code for a state machine in C++ that can be used to detect malicious CAN IDs
# It is designed to be implemented on low-priority CAN buses with higher addresses of CAN IDs
# This will identify any CAN ID that is not one of the ones in the ECU_LIST as quickly as possible and immediately send the command to shut it down

# Only change this based on your IVN configuration
ECU_LIST = sorted([0x100, 0x101, 0x110, 0x150])
# Change this based on the ECU you want it to run on
GENERATED_FOR = 0x110


# Don't change anything below this for your configuration

def main(algData, ecus, ecu_to_catch):
    # generate the code for the state machine from another file
    return generate_cpp(algData, ecus, ecu_to_catch)


def generate_cpp(algData, ecu_list, generated_for):
    # turn the code within the test_case forloop function into a state machine
    beginning = '''\
// Generated by canid_catch_all.py:
// using ECU CAN IDs: {IDs}
// built for ECU bus ID: {generated_for}
void state_machine_run(uint8_t value) {{\n'''.format(IDs=[hex(item) for item in ecu_list], generated_for=hex(generated_for))
    body = ''
    body += '  \n'
    body += '  bitWrite(state, 10 - len, value);\n'
    body += '  len++;\n'
    body += '  \n'
    body += '  if (len == 11 && state == {}) {{\n'.format(generated_for)
    body += '    start_counterattack = true;\n'
    body += '    return;\n'
    body += '  }\n'
    for key, value in algData.GLOBALLY_MALICIOUS_DICT.items():
        body += '  if (len == {key} && value == {value}) {{\n'.format(
            key=key+1, value=value)
        body += '    start_counterattack = true;\n'
        body += '    return;\n'
        body += '  }\n'

    for prefix in algData.LOCALLY_MALICIOUS_PREFIXES:
        decimal_prefix = int(prefix + '0' * (11 - len(prefix)), 2)
        body += '  if (len == {prefix_length} && state == {prefix}) {{\n'.format(
            prefix_length=len(prefix), prefix=decimal_prefix)
        body += '    start_counterattack = true;\n'
        body += '    return;\n'
        body += '  }\n'
    ending = ''
    ending += '  return;\n'
    ending += '}\n'
    ending += '// End generated code\n'
    return beginning + body + ending

# now we are done collecting everything we need and can build out our (sort of) state machine for the CAN ID


# run this if this function is called directly from command line to build specific FSM
if __name__ == "__main__":
    import canid_shared_algs
    algData = canid_shared_algs.algs(ECU_LIST)
    if algData.run_test_cases():
        print(generate_cpp(algData, ECU_LIST, GENERATED_FOR))
