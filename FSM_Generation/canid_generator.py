from asyncore import write
from methods import canid_catch_all, canid_catch_less_than, canid_specific_match, canid_shared_algs
import time
import json
from pathlib import Path
import os
# This is the main file that gets run to build algorithms for every ECU with a specific method of detecting malicious behavior.

# Only change this based on your IVN configuration
ECU_LIST = sorted([0x100, 0x101, 0x110, 0x150])

# change these to determine which ECUs should run what method of detecting malicious behavior
# the ceilings are inclusive with the method
SPECIFIC_MATCH_CEILING = 0x001
LESS_THAN_CEILING = 0x151

TIMER_SIG_FIGS = 7
DEBUG = False

# Don't change anything below this for your configuration


class CanidGenerator:
    def __init__(self, ecus, match_ceil, less_than_ceil, save, test, car_id=None):
        if DEBUG:
            print("\n\nBeginning to compile algorithms for ECUs")
        self.ecus = ecus
        self.match_ceil = match_ceil
        self.less_than_ceil = less_than_ceil
        self.save = save
        self.test = test
        self.car_id = car_id

        # import re-usable c++
        with open("test_all.cpp", "r") as tester_cpp:
            self.test_all = tester_cpp.read()
        with open("test_less.cpp", "r") as tester_cpp:
            self.test_less = tester_cpp.read()
        with open("test_match.cpp", "r") as tester_cpp:
            self.test_match = tester_cpp.read()
        with open("arduino_template50K.ino", "r") as arduino_template:
            self.arduino_template50K = arduino_template.read()
        with open("arduino_template125K.ino", "r") as arduino_template:
            self.arduino_template125K = arduino_template.read()

        # timing variables
        self.compile_time = None
        self.build_time = None
        self.write_time = None

        # tree size variables
        self.global_bits = None
        self.local_prefixes = None
        self.avg_bit_length = None
        self.max_bit_length = None
        self.min_bit_length = None

    def alg_compile(self):
        start = time.time()
        self.algData = canid_shared_algs.algs(self.ecus)
        end = time.time()
        self.compile_time = round(end - start, TIMER_SIG_FIGS)
        if DEBUG:
            print("Finished compiling algorithms for ECUs in {} seconds".format(
                self.compile_time))
        self.global_bits = len(self.algData.GLOBALLY_MALICIOUS_DICT)
        self.local_prefixes = len(self.algData.LOCALLY_MALICIOUS_PREFIXES)
        self.avg_bit_length = self.algData.AVG_BIT_LENGTH
        self.max_bit_length = self.algData.MAX_BIT_LENGTH
        self.min_bit_length = self.algData.MIN_BIT_LENGTH

    def build_FSMs(self):
        if DEBUG:
            print("Beginning to build FSM for ECUs")
        build_start = time.time()
        write_out_buffer = {}
        for ecu in self.ecus:
            ecuid = hex(ecu)
            write_out_buffer[ecuid] = {}
            if ecu <= self.match_ceil:
                write_out_buffer[ecuid]["match type"] = "specific match"
                start = time.time()
                write_out_buffer[ecuid]["FSM"] = canid_specific_match.main(
                    self.algData, self.ecus, ecu)
                end = time.time()
                write_out_buffer[ecuid]["build time"] = round(
                    end - start, TIMER_SIG_FIGS)
            elif ecu <= self.less_than_ceil:
                write_out_buffer[ecuid]["match type"] = "less than"
                start = time.time()
                write_out_buffer[ecuid]["FSM"] = canid_catch_less_than.main(
                    self.algData, self.ecus, ecu)
                end = time.time()
                write_out_buffer[ecuid]["build time"] = round(
                    end - start, TIMER_SIG_FIGS)
            else:
                write_out_buffer[ecuid]["match type"] = "catch all"
                start = time.time()
                write_out_buffer[ecuid]["FSM"] = canid_catch_all.main(
                    self.algData, self.ecus, ecu)
                end = time.time()
                write_out_buffer[ecuid]["build time"] = round(
                    end - start, TIMER_SIG_FIGS)
        self.write_out_buffer = write_out_buffer
        build_end = time.time()
        self.build_time = round(build_end - build_start, TIMER_SIG_FIGS)
        if DEBUG:
            print("Finished building FSM for {} ECUs in {} seconds".format(
                len(self.ecus), self.build_time))

    def write_test_start(self, ecu):
        ecu_int = int(ecu, 16)
        to_write = ""
        to_write += "// This file was generated by canid_generator.py\n"
        to_write += "// ECU: {}\n".format(ecu)
        to_write += "// Build time: {} seconds\n".format(
            self.write_out_buffer[ecu]["build time"])
        to_write += "// Build date: {}\n".format(
            time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()))
        to_write += "// Method: {}\n".format(
            self.write_out_buffer[ecu]["match type"])
        to_write += "\n"
        to_write += "#include <cstdint>\n"
        to_write += "#include <vector>\n"
        to_write += "#include <algorithm>\n"
        to_write += "#include <iostream>\n\n"
        to_write += "using namespace std;\n\n"
        to_write += "// these are valid arduino operations and how they would be written in c++\n"
        to_write += "#define bitRead(value, bit) (((value) >> (bit)) & 0x01)\n"
        to_write += "#define bitSet(value, bit) ((value) |= (1UL << (bit)))\n"
        to_write += "#define bitClear(value, bit) ((value) &= ~(1UL << (bit)))\n"
        to_write += "#define bitWrite(value, bit, bitvalue) ((bitvalue) ? bitSet(value, bit) : bitClear(value, bit))\n"
        to_write += "\n\nuint16_t state = 0;\n"
        to_write += "uint8_t len = 0;\n"
        to_write += "bool start_counterattack = false;\n\n"
        to_write += "\n\n"
        return to_write

    def write_test_end(self, ecu):
        ecu_int = int(ecu, 16)
        to_write = ""
        ecu_str = str(self.ecus).replace(
            "[", "{").replace("]", "}")
        to_write += "vector<int> ecus = {};\n".format(ecu_str)
        to_write += "uint16_t generated_for = {};\n\n".format(
            ecu_int)
        mt = self.write_out_buffer[ecu]["match type"]
        test_function = self.test_match
        if mt == "catch all":
            test_function = self.test_all
        elif mt == "less than":
            test_function = self.test_less
        to_write += test_function
        return to_write

    def write_out(self, speed=None):
        if self.car_id is not None and speed is None:
            self.write_out(125)
        if DEBUG:
            print("Beginning to write out FSM for ECUs")
        write_start = time.time()
        if self.save is not None:
            if self.save == "file":
                with open("results/FSM_Generation.json", "w") as f:
                    json.dump(self.write_out_buffer, f, indent=4)
            elif self.save == "folder":
                for ecu in self.ecus:
                    ecu = hex(ecu)
                    write_ecu = ecu
                    if self.car_id is not None:
                        if speed is None:
                            speed = 50
                        write_ecu = "Arduino/" + \
                            str(speed) + "K" + "/" + "Car" + \
                            str(self.car_id) + "/" + ecu
                    with open("results/FSMs/{}.{}".format(write_ecu, "cpp" if self.test else "ino"), "w") as f:
                        to_write = ''
                        if self.test:
                            to_write += self.write_test_start(ecu)
                            to_write += "{}\n".format(
                                self.write_out_buffer[ecu]["FSM"])
                            to_write += self.write_test_end(ecu)
                        else:
                            if speed == 50:
                                to_write += self.arduino_template50K.split("// FSM")[
                                    0]
                            elif speed == 125:
                                to_write += self.arduino_template125K.split("// FSM")[
                                    0]
                            to_write += "{}\n".format(
                                self.write_out_buffer[ecu]["FSM"])
                            if speed == 50:
                                to_write += self.arduino_template50K.split("// FSM")[
                                    1]
                            elif speed == 125:
                                to_write += self.arduino_template125K.split("// FSM")[
                                    1]
                        f.write(to_write)
            else:
                if DEBUG:
                    print("Invalid save type")
        else:
            print(json.dumps(self.write_out_buffer, indent=4))
        write_end = time.time()
        self.write_time = round(write_end - write_start, TIMER_SIG_FIGS)
        if DEBUG:
            print("Finished writing out FSMs for {} ECUs in {} seconds".format(
                len(self.ecus), self.write_time))

    def write_one(self):
        write_start = time.time()
        ecu = max(self.ecus)
        ecu = hex(ecu)
        write_ecu = ecu
        if self.car_id is not None:
            current_directory = os.getcwd()
            write_ecu = current_directory + "/results/FSMs/Arduino/50K" + "/" + "Car" + \
                str(self.car_id) + "/" + ecu + "/" + ecu
            if self.match_ceil > max(self.ecus):
                write_ecu = current_directory + "/results/FSMs/Arduino/50K" + "/" + "Car" + \
                    str(self.car_id) + "/" + ecu + "-Match/" + ecu + "-Match"
            Path(write_ecu).parent.mkdir(exist_ok=True, parents=True)
        with open("{}.{}".format(write_ecu, "ino"), "w+") as f:
            to_write = ''
            if self.test:
                to_write += self.write_test_start(ecu)
                to_write += "{}\n".format(
                    self.write_out_buffer[ecu]["FSM"])
                to_write += self.write_test_end(ecu)
            else:
                to_write += self.arduino_template50K.split("// FSM")[0]
                to_write += "{}\n".format(
                    self.write_out_buffer[ecu]["FSM"])
                to_write += self.arduino_template50K.split("// FSM")[
                    1]
            f.write(to_write)
        if self.car_id is not None:
            current_directory = os.getcwd()
            write_ecu = current_directory + "/results/FSMs/Arduino/125K" + "/" + "Car" + \
                str(self.car_id) + "/" + ecu + "/" + ecu
            if self.match_ceil > max(self.ecus):
                write_ecu = current_directory + "/results/FSMs/Arduino/50K" + "/" + "Car" + \
                    str(self.car_id) + "/" + ecu + "-Match/" + ecu + "-Match"
            Path(write_ecu).parent.mkdir(exist_ok=True, parents=True)
        with open("{}.{}".format(write_ecu, "ino"), "w+") as f:
            to_write = ''
            if self.test:
                to_write += self.write_test_start(ecu)
                to_write += "{}\n".format(
                    self.write_out_buffer[ecu]["FSM"])
                to_write += self.write_test_end(ecu)
            else:
                to_write += self.arduino_template125K.split("// FSM")[0]
                to_write += "{}\n".format(
                    self.write_out_buffer[ecu]["FSM"])
                to_write += self.arduino_template125K.split("// FSM")[
                    1]
            f.write(to_write)
        write_end = time.time()
        self.write_time = round(write_end - write_start, TIMER_SIG_FIGS)

    def get_stats(self):
        return {
            "compile time": self.compile_time,
            "build time": self.build_time,
            "write time": self.write_time,
            "global bits": self.global_bits,
            "local prefixes": self.local_prefixes,
            "avg bit length": self.avg_bit_length,
            "max bit length": self.max_bit_length,
            "min bit length": self.min_bit_length,
        }


def main(save_location, ecu_list, match_ceil, less_than_ceil, test=True, car_id=None, just_one=False):
    DEBUG = False
    canid_generator = CanidGenerator(
        ecu_list, match_ceil, less_than_ceil, save_location, test, car_id)
    canid_generator.alg_compile()
    canid_generator.build_FSMs()
    if not just_one:
        canid_generator.write_out()
    else:
        canid_generator.write_one()
    return canid_generator.get_stats()


# run this if this function is called directly from command line to build specific FSM
if __name__ == "__main__":
    canid_generator = None
    to_test = True
    save_location = input(
        "Where would you like to save the files? Please enter 'file' to have them overwrite to 'FSM_Generation.json', 'folder' to have them each saved to their own C++ file inside the 'FSMs' folder, or 'none' to not save them and just print them to the console: ")
    if save_location == 'file':
        save_location = 'file'
    elif save_location == 'folder':
        save_location = 'folder'
        to_test = input("Would you like to generate the FSMs as C++ with the testing configurations baked in, or inside the template to run it on an Arduino? Defaults to test. (t)est or (a)rduino")
        if to_test == "t" or to_test == "test":
            to_test = True
        elif to_test == "a" or to_test == "arduino":
            to_test = False
        else:
            print("Invalid input, defaulting to 'test'")
            to_test = True
    elif save_location == 'none':
        save_location = None
    else:
        print("Invalid input, defaulting to 'none'")
        save_location = None
    custom_vals = input(
        "Would you like to enter custom for the ECU list? (y/n) ")
    if custom_vals == "y":
        ECU_LIST = input(
            "Enter the ECU list in hex, separated by commas, or enter 'file' to read in from 'custom_ids.txt': ")
        if ECU_LIST == 'file':
            with open("custom_ids.txt", "r") as f:
                ECU_LIST = f.read()
        ECU_LIST = ECU_LIST.split(",")
        ECU_LIST = [int(item, 16) for item in ECU_LIST]
        ecu_list = sorted(ECU_LIST)
        ceilings = input("Would you like to define ceilings so that different CAN ID ranges use different methods for improved performance? Answering no will prompt you to choose which method you'd like to use. (y/n) ")
        lower_c = None
        upper_c = None
        if ceilings == "y":
            match_ceiling = input(
                "Enter the ceiling for the specific match method (inclusively) in hex: ")
            lower_c = int(match_ceiling, 16)
            less_than_ceiling = input(
                "Enter the ceiling for the less than method (inclusively) in hex: ")
            upper_c = int(less_than_ceiling, 16)
        else:
            method = input(
                "Which method would you like to use for all {} of your ECUs? ((s)pecific_match/(l)ess_than/(a)ll) ".format(len(ECU_LIST)))
            if method == "s":
                lower_c = max(ECU_LIST)
                upper_c = max(ECU_LIST) + 1
            elif method == "l":
                lower_c = min(ECU_LIST) - 1
                upper_c = max(ECU_LIST) + 1
            elif method == "a":
                lower_c = min(ECU_LIST) - 1
                upper_c = min(ECU_LIST)
            else:
                print("Invalid method. Please enter 's', 'l', or 'a'.")
                exit()
        canid_generator = CanidGenerator(
            ecu_list, lower_c, upper_c, save_location, to_test)

    else:
        print("Using values defined in {}".format(__file__))
        canid_generator = CanidGenerator(ECU_LIST,
                                         SPECIFIC_MATCH_CEILING, LESS_THAN_CEILING, save_location, to_test)
    canid_generator.alg_compile()
    canid_generator.build_FSMs()
    canid_generator.write_out()
    print(canid_generator.get_stats())
