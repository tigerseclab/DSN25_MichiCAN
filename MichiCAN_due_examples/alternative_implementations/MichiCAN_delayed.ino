#include "variant.h"
#include <due_can.h>

#define SPEED                    CAN_BPS_125K

//Leave this defined if you use the native port or comment it out if you use the programming port
#define Serial SerialUSB

CAN_FRAME frame1, incoming;
int counter = 0;
int counter2 = 0;
int stuffcnt = 0;
bool can_frame[27];
bool sof = false;
bool start_counterattack = false;
uint16_t state = 0;
uint8_t len = 0;
unsigned long previousMillis = 0;

// Generated by calculate_canid_pattern.py:
// using ECU CAN IDs: ['0x100', '0x101', '0x110', '0x150']
// built for ECU bus ID: 0x110
void state_machine_run(uint8_t value) {

    bitWrite(state, 10 - len, value);
    len++;

    if (state > 272) {
        return;
    }
    if (len == 11 && state == 272) {
        start_counterattack = true;
        return;
    }
    if (len == 1 && value == 1) {
        start_counterattack = true;
        return;
    }
    if (len == 2 && value == 1) {
        start_counterattack = true;
        return;
    }
    if (len == 3 && value == 0) {
        start_counterattack = true;
        return;
    }
    if (len == 4 && value == 1) {
        start_counterattack = true;
        return;
    }
    if (len == 6 && value == 1) {
        start_counterattack = true;
        return;
    }
    if (len == 8 && value == 1) {
        start_counterattack = true;
        return;
    }
    if (len == 9 && value == 1) {
        start_counterattack = true;
        return;
    }
    if (len == 10 && value == 1) {
        start_counterattack = true;
        return;
    }
    if (len == 7 && state == 320) {
        start_counterattack = true;
        return;
    }
    if (len == 11 && state == 273) {
        start_counterattack = true;
        return;
    }
    if (len == 11 && state == 337) {
        start_counterattack = true;
        return;
    }
    return;
}
// End generated code


void reset_state_machine() {
  state = 0;
  len = 0;
}

void TC3_Handler() {
  TC_GetStatus(TC1, 0);
  bool value = PIOA->PIO_PDSR & PIO_PA1A_CANRX0;
  
  if (sof == true) {
    // Start arbitration
    counter2++;
    if (counter2 < 25) {
      if (can_frame[counter2 - 2] != value && stuffcnt == 5) {
        stuffcnt = 0;
        counter2--;
      }
      else if (can_frame[counter2 - 2] == value && stuffcnt < 5) {
        can_frame[counter2 - 1] = value;
        state_machine_run(value);
        //Serial.println(enum_array[state]);
        stuffcnt++;
      }
      else if (can_frame[counter2 - 2] != value && stuffcnt < 5) {
        can_frame[counter2 - 1] = value;
        state_machine_run(value);
        //Serial.println(enum_array[state]);
        stuffcnt = 1;
      }
    }

    if (counter2 == 27) {
      PIOA->PIO_PDR = PIO_PA0A_CANTX0;
      PIOA->PIO_ODR = PIO_PA0A_CANTX0;
      sof = false;
      counter2 = 0;
    }

    else if (counter2 == 20) {
        int can_id_offender = 0;
        for (int i = 1; i <= 11; i++) {
          can_id_offender += can_frame[i] * (1 << (11 - i));
        }
        Serial.print(" (dec ");
        Serial.print(can_id_offender);
        Serial.println(")");
      if (start_counterattack == true) {    // Counterattack
        start_counterattack = false;
        PIOA->PIO_PER = PIO_PA0A_CANTX0;    // Multiplex CAN_TX to GPIO
        PIOA->PIO_OER = PIO_PA0A_CANTX0;    // Define CAN_TX as output
        PIOC->PIO_CODR = PIO_PA0A_CANTX0;   // set pin to LOW
      }
    }
  }

  if (value == 1) {
    counter++;
  }
  else if (value == 0 && counter < 11) {
    counter = 0;
  }

  if (counter >= 11 && value == 0) {    //SOF
    sof = true;
    counter = 0;
    stuffcnt = 1;
    can_frame[0] = 0;
    counter2 = 1;
    reset_state_machine();
    //Serial.println("Start arbitration");
  }

  delayMicroseconds(8);
}

void process_frame() {
  bool value = PIOA->PIO_PDSR & PIO_PA1A_CANRX0;
  
    // Start arbitration
    counter2++;
    if (counter2 < 25) {
      if (can_frame[counter2 - 2] != value && stuffcnt == 5) {
        stuffcnt = 0;
        counter2--;
      }
      else if (can_frame[counter2 - 2] == value && stuffcnt < 5) {
        can_frame[counter2 - 1] = value;
        state_machine_run(value);
        //Serial.println(enum_array[state]);
        stuffcnt++;
      }
      else if (can_frame[counter2 - 2] != value && stuffcnt < 5) {
        can_frame[counter2 - 1] = value;
        state_machine_run(value);
        //Serial.println(enum_array[state]);
        stuffcnt = 1;
      }
    }

    if (counter2 == 27) {
      PIOA->PIO_PDR = PIO_PA0A_CANTX0;
      PIOA->PIO_ODR = PIO_PA0A_CANTX0;
      sof = false;
      counter2 = 0;
    }

    else if (counter2 == 20) {
        int can_id_offender = 0;
        for (int i = 1; i <= 11; i++) {
          can_id_offender += can_frame[i] * (1 << (11 - i));
        }
        Serial.print(" (dec ");
        Serial.print(can_id_offender);
        Serial.println(")");
      if (start_counterattack == true) {    // Counterattack
        start_counterattack = false;
        PIOA->PIO_PER = PIO_PA0A_CANTX0;    // Multiplex CAN_TX to GPIO
        PIOA->PIO_OER = PIO_PA0A_CANTX0;    // Define CAN_TX as output
        PIOC->PIO_CODR = PIO_PA0A_CANTX0;   // set pin to LOW
      }
    }
}

void MichiCAN_Sync() {
  //Starts everytime there is a rising or falling edge
    sof = true;
    counter = 0;
    stuffcnt = 1;
    can_frame[0] = 0;
    counter2 = 1;
    reset_state_machine();
  //NVIC_DisableIRQ(TC3_IRQn);
  detachInterrupt(PIO_PA1A_CANRX0);
}

void setup() {

  // start serial port at 115200 bps:
  Serial.begin(115200);

  // Verify CAN0 and CAN1 initialization, baudrate is 1Mb/s:
  if (Can0.begin(SPEED) &&
      Can1.begin(SPEED)) {
  }
  else {
    Serial.println("CAN initialization (sync) ERROR");
  }

  PMC->PMC_PCER0 |= PMC_PCER0_PID11; // PIOA power ON

  //Multiplex CAN_RX to GPIO (Peripheral Enable Register)
  PIOA->PIO_PER = PIO_PA1A_CANRX0;

  //Set CAN_RX as input (Ouput Disable Register)
  PIOA->PIO_ODR = PIO_PA1A_CANRX0;

  //Disable pull-up on both pins (Pull Up Disable Register)
  PIOA->PIO_PUDR = PIO_PA1A_CANRX0;
  PIOA->PIO_PUDR = PIO_PA0A_CANTX0;
  attachInterrupt(PIO_PA1A_CANRX0, MichiCAN_Sync, FALLING);
  Can0.watchFor();
}

void loop()
{
  if (sof == true) {
    process_frame();
    delayMicroseconds(4);
  }
}
